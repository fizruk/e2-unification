-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/fizruk/e2-unification#readme</a>
@package e2-unification
@version 0.1.0.0

module E2.Term

-- | A variable token, identified by its name.
newtype Variable
Variable :: String -> Variable
[getVariable] :: Variable -> String

-- | A label (such as constructor label).
newtype Label
Label :: String -> Label
[getLabel] :: Label -> String

-- | A term, parametrised by the type of its metavariables and variables.
data Term metavar var

-- | A variable term.
Var :: var -> Term metavar var

-- | A constructor (a.k.a. function symbol), fully applied to all its
--   arguments.
Con :: Label -> [ArgTerm metavar var] -> Term metavar var

-- | A parametrised metavariable.
MetaVar :: metavar -> [Term metavar var] -> Term metavar var

-- | An argument term (i.e. occuring in the list of arguments to a
--   constructor).
data ArgTerm metavar var

-- | Regular subterm.
Regular :: Term metavar var -> ArgTerm metavar var

-- | Scoped subterm (introduces one bound variable).
Scoped :: Term metavar (Inc var) -> ArgTerm metavar var

-- | A convenient version of <a>Term</a>.
type Term' = Term Variable Variable
type ArgTerm' = ArgTerm Variable

-- | Extract a list of all metavariable names that occur in a given term.
metavars :: Term m a -> [m]

-- | Extract a list of all metavariable names that occur in a given argment
--   term.
metavarsArg :: ArgTerm m a -> [m]

-- | Substitute all variables in a term.
substitute :: (a -> Term m b) -> Term m a -> Term m b

-- | Substitute all variables in an argument term.
substituteArg :: (a -> Term m b) -> ArgTerm m a -> ArgTerm m b

-- | Substitute all meta variables in a term. Note that here all
--   metavariables must have a substitution defined.
substituteMeta :: (m -> Term n (IncMany a)) -> Term m a -> Term n a

-- | Substitute all meta variables in an argument term. Note that here all
--   metavariables must have a substitution defined.
substituteMetaArg :: (m -> Term n (IncMany a)) -> ArgTerm m a -> ArgTerm n a

-- | Substitute some meta variables in a term. Here, <a>Nothing</a> means
--   that corresponding meta variable should not be substituted (but
--   substitution may still take place in its parameters).
substituteMeta' :: (m -> Maybe (Term m (IncMany a))) -> Term m a -> Term m a

-- | Substitute some meta variables in an argument term. Here,
--   <a>Nothing</a> means that corresponding meta variable should not be
--   substituted (but substitution may still take place in its parameters).
substituteMetaArg' :: (m -> Maybe (Term m (IncMany a))) -> ArgTerm m a -> ArgTerm m a

-- | Rename meta variables in a term.
renameMeta :: (m -> n) -> Term m a -> Term n a

-- | Rename meta variables in an argument term.
renameMetaArg :: (m -> n) -> ArgTerm m a -> ArgTerm n a

-- | Default fresh names for variables:
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ putStrLn $ take 5 defaultFreshVars
--   x₁
--   x₂
--   x₃
--   x₄
--   x₅
--   </pre>
defaultFreshVars :: IsString a => [a]

-- | Default stream of fresh names for bound variables.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ putStrLn $ take 5 defaultFreshBoundVars
--   z₁
--   z₂
--   z₃
--   z₄
--   z₅
--   </pre>
defaultFreshBoundVars :: IsString a => [a]

-- | Default strem of fresh names for meta variables.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ putStrLn $ take 5 defaultFreshMetaVars
--   m₁
--   m₂
--   m₃
--   m₄
--   m₅
--   </pre>
defaultFreshMetaVars :: IsString a => [a]

-- | Make an infinite stream of default names with numeric subscript.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ putStrLn $ take 5 (mkDefaultFreshVars "example")
--   example₁
--   example₂
--   example₃
--   example₄
--   example₅
--   </pre>
mkDefaultFreshVars :: IsString a => String -> [a]

-- | Pretty print a <a>Term'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; t = Con "APP" [Regular (Con "LAM" [Scoped (MetaVar "m1" [Var Z])]), Regular (MetaVar "m2" [])]
--   
--   &gt;&gt;&gt; putStrLn $ ppTerm' t
--   APP(LAM(x₁.m1[x₁]), m2[])
--   </pre>
ppTerm' :: Term' -> String

-- | Pretty print a <a>Term</a>.
ppTerm :: [String] -> (a -> String) -> Term Variable a -> String

-- | Pretty print an argument term (regular or scoped).
ppArgTerm :: [String] -> (a -> String) -> ArgTerm Variable a -> String

-- | Pretty-print a variable (using a default name for the bound variable).
ppInc :: String -> Inc String -> String

-- | Pretty-print a variable (using a list of default names for the bound
--   variables).
ppIncMany :: [String] -> IncMany String -> String

-- | A version of <a>!!</a> with a custom error message.
(!!?) :: [a] -> String -> Int -> a

-- | Add one (bound) variable.
data Inc var

-- | The bound variable.
Z :: Inc var

-- | A free variable (or another bound variable from the outside).
S :: var -> Inc var

-- | Add arbitrarily many bound variables.
data IncMany var

-- | The bound variable.
B :: Int -> IncMany var

-- | A free variable (or another bound variable from the outside).
F :: var -> IncMany var

-- | Instantiate bound variables in a generalized term.
instantiateMany :: Monad f => (Int -> f a) -> f (IncMany a) -> f a

-- | Convert two scopes into one.
joinInc :: Inc (IncMany a) -> IncMany a

-- | Commute scopes.
commuteInc :: Inc (IncMany a) -> IncMany (Inc a)

-- | Remove bound variables if possible.
removeInc :: Alternative f => Inc a -> f a

-- | Remove bound variables if possible.
removeIncMany :: Alternative f => IncMany a -> f a

-- | Remove the first bound variable if possible.
decIncMany :: Alternative f => IncMany a -> f (IncMany a)

-- | Remove the first bound variable from a generalised term.
removeAllIncMany :: (Traversable t, Alternative f) => t (IncMany a) -> f (t a)
instance Data.String.IsString E2.Term.Variable
instance GHC.Show.Show E2.Term.Variable
instance GHC.Classes.Eq E2.Term.Variable
instance Data.String.IsString E2.Term.Label
instance GHC.Show.Show E2.Term.Label
instance GHC.Classes.Eq E2.Term.Label
instance Data.Traversable.Traversable E2.Term.Inc
instance Data.Foldable.Foldable E2.Term.Inc
instance GHC.Base.Functor E2.Term.Inc
instance GHC.Show.Show var => GHC.Show.Show (E2.Term.Inc var)
instance GHC.Classes.Eq var => GHC.Classes.Eq (E2.Term.Inc var)
instance Data.Traversable.Traversable (E2.Term.Term metavar)
instance Data.Foldable.Foldable (E2.Term.Term metavar)
instance GHC.Base.Functor (E2.Term.Term metavar)
instance (GHC.Show.Show var, GHC.Show.Show metavar) => GHC.Show.Show (E2.Term.Term metavar var)
instance (GHC.Classes.Eq var, GHC.Classes.Eq metavar) => GHC.Classes.Eq (E2.Term.Term metavar var)
instance Data.Traversable.Traversable (E2.Term.ArgTerm metavar)
instance Data.Foldable.Foldable (E2.Term.ArgTerm metavar)
instance GHC.Base.Functor (E2.Term.ArgTerm metavar)
instance (GHC.Show.Show var, GHC.Show.Show metavar) => GHC.Show.Show (E2.Term.ArgTerm metavar var)
instance (GHC.Classes.Eq var, GHC.Classes.Eq metavar) => GHC.Classes.Eq (E2.Term.ArgTerm metavar var)
instance Data.Traversable.Traversable E2.Term.IncMany
instance Data.Foldable.Foldable E2.Term.IncMany
instance GHC.Base.Functor E2.Term.IncMany
instance GHC.Show.Show var => GHC.Show.Show (E2.Term.IncMany var)
instance GHC.Classes.Eq var => GHC.Classes.Eq (E2.Term.IncMany var)
instance GHC.Base.Applicative (E2.Term.Term metavar)
instance GHC.Base.Monad (E2.Term.Term metavar)

module E2.Term.Unification

-- | Quantify over arbitrarily many variables using <a>Inc</a>.
data Forall t var

-- | &lt;math&gt;
Forall :: Forall t (Inc var) -> Forall t var

-- | Ground term/constraint (no quantifiers).
Ground :: t var -> Forall t var

-- | A rule &lt;math&gt;.
data Rule metavar a
(:->) :: Term metavar a -> Term metavar a -> Rule metavar a

-- | Extract rule's left hand side.
ruleLHS :: Rule m Void -> Term m Void

-- | Extract left hand side from a collection of rules.
rulesLHS :: [Rule m Void] -> [Term m Void]

-- | A ground constraint has no quantifiers.
data GroundConstraint metavar var

-- | &lt;math&gt;
(:==:) :: Term metavar var -> Term metavar var -> GroundConstraint metavar var

-- | A constraint is a ground constraint put under some number of
--   quantifiers.
--   
--   &lt;math&gt;
type Constraint metavar = Forall (GroundConstraint metavar)

-- | A meta variable substitution.
data MetaSubst m var
MetaSubst :: m -> Int -> Term m (IncMany var) -> MetaSubst m var

-- | Meta variable to be substituted.
[metaSubstVar] :: MetaSubst m var -> m

-- | Meta variable arity (for checks).
[metaSubstArity] :: MetaSubst m var -> Int

-- | Meta variable body (a scoped term).
[metaSubstBody] :: MetaSubst m var -> Term m (IncMany var)

-- | Construct a meta variable substitution and check that its declared
--   arity is not exceeded in the body.
metaSubst :: m -> Int -> Term m (IncMany var) -> MetaSubst m var

-- | A collection of simultaneous meta variable substitutions.
newtype MetaSubsts m var
MetaSubsts :: [MetaSubst m var] -> MetaSubsts m var
[getMetaSubsts] :: MetaSubsts m var -> [MetaSubst m var]

-- | Convert meta substitutions into a lookup list.
toLookupList :: MetaSubsts m var -> [(m, Term m (IncMany var))]

-- | Apply meta substitutions to a given constraint.
applySubsts :: Eq m => MetaSubsts m a -> Constraint m a -> Constraint m a

-- | The unification context (a combination of backtracking and fresh name
--   supply).
newtype Unify v a
Unify :: LogicT (Fresh v) a -> Unify v a
[runUnify] :: Unify v a -> LogicT (Fresh v) a

-- | Run a unification computation using default fresh name supply and
--   extracting the first result.
--   
--   NOTE: will throw an exception when no solution is available.
defaultUnify :: Unify Variable a -> a

-- | Attempt applying one step of &lt;math&gt;-unification to a collection
--   of constraints.
--   
--   This will try to simplify constraints in the following way:
--   
--   <ol>
--   <li>If there are no constraints to simplify, then exit
--   successfully.</li>
--   <li>Apply <a>delete</a> or <a>eliminate</a> rule to some constraint if
--   possible.</li>
--   <li>Simplify any rigid-rigid constraint with <a>decompose</a> or
--   <a>mutate</a> rules.</li>
--   <li>Otherwise, apply <a>project</a>, <a>imitate</a>, or
--   <a>mutateMeta</a> rules.</li>
--   </ol>
tryE2 :: (Eq m, Eq a, MonadPlus f, MonadFail f, MonadFresh m f, MonadLogic f) => [Rule m Void] -> [Constraint m a] -> f ([Constraint m a], MetaSubsts m a)

-- | Perform unificiation procedure, using DFS and limiting search to a
--   fixed maximum depth. If maximum depth is reached, but not all
--   constraints are simplified, leftover constraints are returned along
--   with intermediate substitution.
unifyDFS :: (Eq m, Eq a, MonadPlus f, MonadFail f, MonadFresh m f, MonadLogic f) => Int -> [Rule m Void] -> [Constraint m a] -> f ([Constraint m a], MetaSubsts m a)

-- | Perform unificiation procedure, using k-depth DFS and limiting search
--   to a fixed maximum depth and BFS iterations. If maximum depth is
--   reached, but not all constraints are simplified, these solutions are
--   discarded.
unifyBFSviaDFS :: (Eq m, Eq a, MonadPlus f, MonadFail f, MonadFresh m f, MonadLogic f) => Int -> Int -> [Rule m Void] -> [Constraint m a] -> f (MetaSubsts m a)

-- | Attempt to find a solution without any leftover constraints. If such a
--   solution exists, return corresponding substitution (using
--   <a>Right</a>). Otherwise, collect all partial solutions in a list
--   (using <a>Left</a>).
tryClose :: MonadLogic f => f ([Constraint m a], MetaSubsts m a) -> f (Either [([Constraint m a], MetaSubsts m a)] (MetaSubsts m a))

-- | Extract all meta variables from a constraint.
constraintMetaVars :: Constraint m a -> [m]

-- | Check if constraint is rigid-rigid (i.e. both sides are not meta
--   variables).
isRigidRigid :: Constraint m a -> Bool
ppConstraints' :: [Constraint Variable Variable] -> String
ppConstraint' :: Constraint Variable Variable -> String
ppConstraint :: [String] -> (a -> String) -> Constraint Variable a -> String
ppMetaSubsts' :: MetaSubsts Variable Variable -> String
ppMetaSubsts :: [String] -> (a -> String) -> MetaSubsts Variable a -> String
ppMetaSubst :: [String] -> (a -> String) -> MetaSubst Variable a -> String
ppRules :: [Rule Variable Void] -> String

-- | Delete rule: &lt;math&gt;
delete :: (Eq m, Eq a, MonadPlus f, MonadFail f, MonadFresh m f) => GroundConstraint m (IncMany a) -> f ([Constraint m (IncMany a)], MetaSubsts m (IncMany a))

-- | Decompose rule: &lt;math&gt; where
--   
--   <ul>
--   <li>&lt;math&gt; for all &lt;math&gt;</li>
--   <li>&lt;math&gt; for all &lt;math&gt;</li>
--   </ul>
decompose :: (Eq m, Eq a, MonadPlus f, MonadFail f, MonadFresh m f) => GroundConstraint m (IncMany a) -> f ([Constraint m (IncMany a)], MetaSubsts m (IncMany a))

-- | Eliminate rule: &lt;math&gt; where
--   
--   <ul>
--   <li>&lt;math&gt;</li>
--   <li>&lt;math&gt; is a list of distinct bound variables (from
--   &lt;math&gt;)</li>
--   <li>&lt;math&gt; does not occur in &lt;math&gt;</li>
--   </ul>
eliminate :: (Eq m, Eq a, MonadPlus f, MonadFail f, MonadFresh m f) => GroundConstraint m (IncMany a) -> f ([Constraint m (IncMany a)], MetaSubsts m (IncMany a))

-- | Imitate rule: &lt;math&gt; where
--   
--   <ul>
--   <li>&lt;math&gt;</li>
--   <li>&lt;math&gt; for all &lt;math&gt;</li>
--   <li>&lt;math&gt; for all &lt;math&gt;</li>
--   <li>&lt;math&gt; are fresh meta variables</li>
--   <li>&lt;math&gt; does not occur in &lt;math&gt; or &lt;math&gt;</li>
--   </ul>
imitate :: (Eq m, Eq a, MonadPlus f, MonadFail f, MonadFresh m f) => GroundConstraint m (IncMany a) -> f ([Constraint m (IncMany a)], MetaSubsts m (IncMany a))

-- | Project rule: &lt;math&gt; where
--   
--   <ul>
--   <li>&lt;math&gt;</li>
--   <li>&lt;math&gt;</li>
--   <li>&lt;math&gt; does not occur in &lt;math&gt;</li>
--   </ul>
project :: (Eq m, Eq a, MonadPlus f, MonadFail f, MonadFresh m f) => GroundConstraint m (IncMany a) -> f ([Constraint m (IncMany a)], MetaSubsts m (IncMany a))

-- | Mutate rule: &lt;math&gt; where
--   
--   <ul>
--   <li>&lt;math&gt; is in &lt;math&gt;</li>
--   <li>&lt;math&gt; for all &lt;math&gt;</li>
--   <li>&lt;math&gt; for all &lt;math&gt;</li>
--   <li>&lt;math&gt;</li>
--   </ul>
mutate :: (Eq m, Eq a, MonadPlus f, MonadFail f, MonadFresh m f) => [Rule m Void] -> [Term m (IncMany a)] -> GroundConstraint m (IncMany a) -> f ([Constraint m (IncMany a)], MetaSubsts m (IncMany a))

-- | Mutate (meta) rule: &lt;math&gt; where
--   
--   <ul>
--   <li>&lt;math&gt; is in &lt;math&gt;</li>
--   <li>&lt;math&gt;</li>
--   <li>&lt;math&gt; for all &lt;math&gt;</li>
--   <li>&lt;math&gt; for all &lt;math&gt;</li>
--   <li>&lt;math&gt;</li>
--   <li>&lt;math&gt; does not occur in &lt;math&gt;</li>
--   </ul>
mutateMeta :: (Eq m, Eq a, MonadPlus f, MonadFail f, MonadFresh m f) => [Rule m Void] -> [Term m (IncMany a)] -> GroundConstraint m (IncMany a) -> f ([Constraint m (IncMany a)], MetaSubsts m (IncMany a))

-- | Check whether given list of terms is a list of distinct bound
--   variables. Return the function appropriate to use in substitution.
distinctBoundVars :: [Term m (IncMany a)] -> Maybe (IncMany a -> Term m (IncMany (IncMany a)))

-- | Generate a fresh meta variable corresponding to an argument of a
--   constructor.
--   
--   Used in <a>imitate</a> and <a>mutateMeta</a> rules.
argTermToMetaVar :: MonadFresh m f => [Term m var] -> ArgTerm m var -> WriterT [Constraint m var] f (ArgTerm m (IncMany var))

-- | Generate a fresh version of a rewrite rule given a list of additional
--   parameters for the meta variables.
--   
--   Used in <a>mutate</a> and <a>mutateMeta</a> rules.
freshRule :: (Eq m, MonadFresh m f) => [Term m a] -> Rule m Void -> f (Rule m a)

-- | Rewrite rules for lambda calculus with pairs.
rulesLambda :: [Rule Variable Void]

-- | A helper to create application terms &lt;math&gt;
app :: Term Variable a -> Term Variable a -> Term Variable a

-- | A helper to create lambda abstraction terms &lt;math&gt;
lam :: Term Variable (Inc a) -> Term Variable a

-- | A helper to create first project terms &lt;math&gt;
first :: Term Variable a -> Term Variable a

-- | A helper to create second project terms &lt;math&gt;
second :: Term Variable a -> Term Variable a

-- | A helper to create pair terms &lt;math&gt;
pair :: Term Variable a -> Term Variable a -> Term Variable a

-- | <pre>
--   &gt;&gt;&gt; putStrLn $ ppTerm' ex1
--   APP(LAM(x₁.m1[x₁]), m2[])
--   </pre>
ex1 :: Term Variable a

-- | <pre>
--   &gt;&gt;&gt; putStrLn $ ppTerm' ex2
--   m1[m2[]]
--   </pre>
ex2 :: Term Variable a

-- | <pre>
--   &gt;&gt;&gt; putStrLn $ ppTerm' ex3
--   APP(m[], x)
--   </pre>
ex3 :: Term'

-- | <pre>
--   &gt;&gt;&gt; putStrLn $ ppConstraint' ex4
--   APP(m[y], x) =?= y
--   </pre>
ex4 :: Constraint Variable Variable

-- | <pre>
--   &gt;&gt;&gt; putStrLn $ ppConstraint' ex5
--   forall x₁.forall x₂.m1[x₂, x₁] =?= APP(x₁, x₂)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ ppMetaSubsts' $ defaultUnify $ unifyBFSviaDFS 1 5 rulesLambda [ ex5 ]
--   m1[x₁, x₂] -&gt; APP(x₂, x₁)
--   </pre>
ex5 :: Constraint Variable Variable

-- | <pre>
--   &gt;&gt;&gt; putStrLn $ ppConstraint' ex6
--   APP(m[], PAIR(LAM(x₁.APP(x₁, y)), g)) =?= APP(g, y)
--   </pre>
--   
--   FIXME: unification does not finish in reasonable time!
ex6 :: Constraint Variable Variable

-- | <pre>
--   &gt;&gt;&gt; putStrLn $ ppConstraint' ex7
--   m[y, g] =?= APP(g, y)
--   
--   &gt;&gt;&gt; putStrLn $ ppMetaSubsts' $ defaultUnify $ unifyBFSviaDFS 1 5 rulesLambda [ ex7 ]
--   m[x₁, x₂] -&gt; APP(x₂, x₁)
--   </pre>
ex7 :: Constraint Variable Variable

-- | <pre>
--   &gt;&gt;&gt; putStrLn $ ppConstraint' ex8
--   APP(m[y], g) =?= APP(g, y)
--   </pre>
--   
--   FIXME: takes too long &gt;&gt;&gt; putStrLn $ ppMetaSubsts' $
--   defaultUnify $ unifyBFSviaDFS 1 4 rulesLambda [ ex8 ] m[x₁] -&gt;
--   LAM(x₂.APP(x₂, x₁))
ex8 :: Constraint Variable Variable

-- | <pre>
--   &gt;&gt;&gt; putStrLn $ ppConstraint' ex9
--   m[PAIR(y, g)] =?= g
--   </pre>
--   
--   FIXME: takes a bit too long and contains unresolved metavariable!
--   &gt;&gt;&gt; putStrLn $ ppMetaSubsts' $ defaultUnify $ unifyBFSviaDFS
--   1 4 rulesLambda [ ex9 ] m[x₁] -&gt; APP(LAM(x₂.SECOND(x₁)), m₉[x₁])
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ ppMetaSubsts' $ defaultUnify $ unifyBFSviaDFS 1 5 rulesLambda [ ex9 ]
--   m[x₁] -&gt; SECOND(x₁)
--   </pre>
ex9 :: Constraint Variable Variable

-- | A monad transformer with fresh name supply.
newtype FreshT v m a
FreshT :: StateT [v] m a -> FreshT v m a
[runFreshT] :: FreshT v m a -> StateT [v] m a

-- | Evaluate a computation with given supply of fresh names.
evalFreshT :: Monad m => FreshT v m a -> [v] -> m a

-- | Simple fresh name supply context.
type Fresh v = FreshT v Identity

-- | Evaluate a computation with given supply of fresh names.
evalFresh :: Fresh v a -> [v] -> a

-- | A monad that is capable of generating fresh names of type <tt>v</tt>.
class Monad m => MonadFresh v m | m -> v

-- | Generate a fresh name.
fresh :: MonadFresh v m => m v

-- | Non-deterministically select one element out of a list.
--   
--   <pre>
--   &gt;&gt;&gt; selectOne [1..3] :: [(Int, [Int])]
--   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
--   </pre>
selectOne :: Alternative f => [a] -> f (a, [a])

-- | All possible splits of a list into an element and a list of other
--   elements.
--   
--   <pre>
--   &gt;&gt;&gt; splits [1..3]
--   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
--   </pre>
splits :: [a] -> [(a, [a])]

-- | Choose a value from a list.
choose :: Alternative f => [a] -> f a

-- | Try the second computation only if the first one fails (i.e. no
--   backtracking).
--   
--   The following examples show the difference between <a>orElse</a> and
--   <a>mplus</a> for <a>Logic</a>:
--   
--   <pre>
--   &gt;&gt;&gt; observeAll (pure 1 `orElse` pure 2)
--   [1]
--   
--   &gt;&gt;&gt; observeAll (pure 1 `mplus` pure 2)
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; observeAll $ do { x &lt;- pure 1 `orElse` pure 2; guard (even x); return x }
--   []
--   
--   &gt;&gt;&gt; observeAll $ do { x &lt;- pure 1 `mplus` pure 2; guard (even x); return x }
--   [2]
--   </pre>
orElse :: MonadLogic m => m a -> m a -> m a
notrace :: String -> a -> a
instance (GHC.Show.Show a, GHC.Show.Show metavar) => GHC.Show.Show (E2.Term.Unification.Rule metavar a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq metavar) => GHC.Classes.Eq (E2.Term.Unification.Rule metavar a)
instance Data.Traversable.Traversable (E2.Term.Unification.GroundConstraint metavar)
instance Data.Foldable.Foldable (E2.Term.Unification.GroundConstraint metavar)
instance GHC.Base.Functor (E2.Term.Unification.GroundConstraint metavar)
instance (GHC.Show.Show var, GHC.Show.Show metavar) => GHC.Show.Show (E2.Term.Unification.GroundConstraint metavar var)
instance (GHC.Classes.Eq var, GHC.Classes.Eq metavar) => GHC.Classes.Eq (E2.Term.Unification.GroundConstraint metavar var)
instance Data.Traversable.Traversable (E2.Term.Unification.MetaSubst m)
instance Data.Foldable.Foldable (E2.Term.Unification.MetaSubst m)
instance GHC.Base.Functor (E2.Term.Unification.MetaSubst m)
instance (GHC.Show.Show m, GHC.Show.Show var) => GHC.Show.Show (E2.Term.Unification.MetaSubst m var)
instance Data.Traversable.Traversable (E2.Term.Unification.MetaSubsts m)
instance Data.Foldable.Foldable (E2.Term.Unification.MetaSubsts m)
instance GHC.Base.Functor (E2.Term.Unification.MetaSubsts m)
instance (GHC.Show.Show m, GHC.Show.Show var) => GHC.Show.Show (E2.Term.Unification.MetaSubsts m var)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (E2.Term.Unification.FreshT v m)
instance Control.Monad.Trans.Class.MonadTrans (E2.Term.Unification.FreshT v)
instance GHC.Base.Monad m => GHC.Base.Monad (E2.Term.Unification.FreshT v m)
instance GHC.Base.Monad m => GHC.Base.Applicative (E2.Term.Unification.FreshT v m)
instance GHC.Base.Functor m => GHC.Base.Functor (E2.Term.Unification.FreshT v m)
instance Control.Monad.Logic.Class.MonadLogic (E2.Term.Unification.Unify v)
instance E2.Term.Unification.MonadFresh v (E2.Term.Unification.Unify v)
instance Control.Monad.Fail.MonadFail (E2.Term.Unification.Unify v)
instance GHC.Base.MonadPlus (E2.Term.Unification.Unify v)
instance GHC.Base.Monad (E2.Term.Unification.Unify v)
instance GHC.Base.Alternative (E2.Term.Unification.Unify v)
instance GHC.Base.Applicative (E2.Term.Unification.Unify v)
instance GHC.Base.Functor (E2.Term.Unification.Unify v)
instance (GHC.Base.Monoid w, E2.Term.Unification.MonadFresh v m) => E2.Term.Unification.MonadFresh v (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance GHC.Base.Monad m => E2.Term.Unification.MonadFresh v (E2.Term.Unification.FreshT v m)
instance E2.Term.Unification.MonadFresh v m => E2.Term.Unification.MonadFresh v (Control.Monad.Logic.LogicT m)
instance GHC.Base.MonadPlus m => GHC.Base.Alternative (E2.Term.Unification.FreshT v m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (E2.Term.Unification.FreshT v m)
instance GHC.Classes.Eq m => GHC.Base.Semigroup (E2.Term.Unification.MetaSubsts m var)
instance GHC.Classes.Eq m => GHC.Base.Monoid (E2.Term.Unification.MetaSubsts m var)
instance (forall a. GHC.Classes.Eq a => GHC.Classes.Eq (t a), GHC.Classes.Eq var) => GHC.Classes.Eq (E2.Term.Unification.Forall t var)
instance (forall a. GHC.Show.Show a => GHC.Show.Show (t a), GHC.Show.Show var) => GHC.Show.Show (E2.Term.Unification.Forall t var)
instance GHC.Base.Functor t => GHC.Base.Functor (E2.Term.Unification.Forall t)
instance Data.Foldable.Foldable t => Data.Foldable.Foldable (E2.Term.Unification.Forall t)
instance Data.Traversable.Traversable t => Data.Traversable.Traversable (E2.Term.Unification.Forall t)
